package collector

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/sds-ebpf/agent/pkg/config"
)

// Event types matching eBPF definitions
const (
	EventTypeProcessExec = 1
	EventTypeProcessExit = 2
	EventTypeSyscall     = 3
	EventTypeTCPConnect  = 4
)

// Event represents a unified telemetry event
type Event struct {
	Type      string                 `json:"type"`
	Timestamp time.Time              `json:"timestamp"`
	PID       uint32                 `json:"pid"`
	UID       uint32                 `json:"uid,omitempty"`
	Comm      string                 `json:"comm,omitempty"`
	Data      map[string]interface{} `json:"data"`
}

// Collector manages eBPF program loading and event collection
type Collector struct {
	cfg       *config.Config
	objs      *observerObjects
	links     []link.Link
	reader    *ringbuf.Reader
	running   bool
}

// eBPF objects (auto-generated by bpf2go, we'll define them manually for now)
type observerObjects struct {
	Programs observerPrograms
	Maps     observerMaps
}

type observerPrograms struct {
	HandleExec           *ebpf.Program `ebpf:"handle_exec"`
	HandleExit           *ebpf.Program `ebpf:"handle_exit"`
	HandleSyscallEnter   *ebpf.Program `ebpf:"handle_syscall_enter"`
	HandleSyscallExit    *ebpf.Program `ebpf:"handle_syscall_exit"`
	TraceTCPConnect      *ebpf.Program `ebpf:"trace_tcp_connect"`
}

type observerMaps struct {
	Events             *ebpf.Map `ebpf:"events"`
	SyscallEntryTimes  *ebpf.Map `ebpf:"syscall_entry_times"`
}

// NewCollector creates a new eBPF collector
func NewCollector(cfg *config.Config) (*Collector, error) {
	c := &Collector{
		cfg: cfg,
	}

	// NOTE: In production, you would use `go generate` with bpf2go to auto-generate
	// the eBPF loading code. For this minimal example, we're showing the structure.
	//
	// The actual loading would be:
	//   objs := observerObjects{}
	//   if err := loadObserverObjects(&objs, nil); err != nil {
	//       return nil, err
	//   }
	//
	// For now, we'll return a placeholder error indicating this needs compilation

	return c, nil
}

// Start begins event collection
func (c *Collector) Start(events chan<- Event) error {
	if c.running {
		return errors.New("collector already running")
	}

	// In production, this would:
	// 1. Attach eBPF programs to tracepoints/kprobes
	// 2. Open ring buffer reader
	// 3. Start reading events in a goroutine
	//
	// Example pseudo-code:
	//
	// c.links = append(c.links, attachProgram(c.objs.Programs.HandleExec))
	// c.reader, err = ringbuf.NewReader(c.objs.Maps.Events)
	//
	// go c.readEvents(events)

	c.running = true
	log.Println("Collector started (placeholder mode - needs eBPF compilation)")

	// Placeholder: Generate some mock events for testing
	go c.generateMockEvents(events)

	return nil
}

// Stop stops event collection
func (c *Collector) Stop() {
	c.running = false
}

// Close cleans up eBPF resources
func (c *Collector) Close() error {
	c.Stop()

	// Close all links
	for _, l := range c.links {
		if l != nil {
			l.Close()
		}
	}

	// Close ring buffer reader
	if c.reader != nil {
		c.reader.Close()
	}

	// Close eBPF objects
	if c.objs != nil {
		// c.objs.Close() // Would be called on generated structs
	}

	return nil
}

// readEvents reads from the ring buffer and parses events
func (c *Collector) readEvents(events chan<- Event) {
	for c.running {
		record, err := c.reader.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				return
			}
			log.Printf("Error reading from ring buffer: %v", err)
			continue
		}

		event, err := c.parseEvent(record.RawSample)
		if err != nil {
			log.Printf("Error parsing event: %v", err)
			continue
		}

		events <- event
	}
}

// parseEvent parses raw bytes from eBPF into an Event
func (c *Collector) parseEvent(data []byte) (Event, error) {
	if len(data) < 4 {
		return Event{}, fmt.Errorf("data too short")
	}

	reader := bytes.NewReader(data)
	var eventType uint32
	if err := binary.Read(reader, binary.LittleEndian, &eventType); err != nil {
		return Event{}, err
	}

	switch eventType {
	case EventTypeProcessExec:
		return c.parseProcessExecEvent(reader)
	case EventTypeProcessExit:
		return c.parseProcessExitEvent(reader)
	case EventTypeSyscall:
		return c.parseSyscallEvent(reader)
	case EventTypeTCPConnect:
		return c.parseTCPConnectEvent(reader)
	default:
		return Event{}, fmt.Errorf("unknown event type: %d", eventType)
	}
}

func (c *Collector) parseProcessExecEvent(r *bytes.Reader) (Event, error) {
	var (
		timestamp uint64
		pid, ppid, uid, gid uint32
		comm [16]byte
		filename [256]byte
		cgroupID uint64
	)

	binary.Read(r, binary.LittleEndian, &timestamp)
	binary.Read(r, binary.LittleEndian, &pid)
	binary.Read(r, binary.LittleEndian, &ppid)
	binary.Read(r, binary.LittleEndian, &uid)
	binary.Read(r, binary.LittleEndian, &gid)
	binary.Read(r, binary.LittleEndian, &comm)
	binary.Read(r, binary.LittleEndian, &filename)
	binary.Read(r, binary.LittleEndian, &cgroupID)

	return Event{
		Type:      "process.exec",
		Timestamp: time.Unix(0, int64(timestamp)),
		PID:       pid,
		UID:       uid,
		Comm:      cstr(comm[:]),
		Data: map[string]interface{}{
			"ppid":      ppid,
			"gid":       gid,
			"filename":  cstr(filename[:]),
			"cgroup_id": cgroupID,
		},
	}, nil
}

func (c *Collector) parseProcessExitEvent(r *bytes.Reader) (Event, error) {
	var (
		timestamp uint64
		pid, exitCode uint32
	)

	binary.Read(r, binary.LittleEndian, &timestamp)
	binary.Read(r, binary.LittleEndian, &pid)
	binary.Read(r, binary.LittleEndian, &exitCode)

	return Event{
		Type:      "process.exit",
		Timestamp: time.Unix(0, int64(timestamp)),
		PID:       pid,
		Data: map[string]interface{}{
			"exit_code": exitCode,
		},
	}, nil
}

func (c *Collector) parseSyscallEvent(r *bytes.Reader) (Event, error) {
	var (
		timestamp uint64
		pid, uid uint32
		comm [16]byte
		syscallID, duration uint64
		syscallName [32]byte
	)

	binary.Read(r, binary.LittleEndian, &timestamp)
	binary.Read(r, binary.LittleEndian, &pid)
	binary.Read(r, binary.LittleEndian, &uid)
	binary.Read(r, binary.LittleEndian, &comm)
	binary.Read(r, binary.LittleEndian, &syscallID)
	binary.Read(r, binary.LittleEndian, &syscallName)
	binary.Read(r, binary.LittleEndian, &duration)

	return Event{
		Type:      "syscall",
		Timestamp: time.Unix(0, int64(timestamp)),
		PID:       pid,
		UID:       uid,
		Comm:      cstr(comm[:]),
		Data: map[string]interface{}{
			"syscall_id":   syscallID,
			"syscall_name": cstr(syscallName[:]),
			"duration_ns":  duration,
		},
	}, nil
}

func (c *Collector) parseTCPConnectEvent(r *bytes.Reader) (Event, error) {
	var (
		timestamp uint64
		pid, uid uint32
		comm [16]byte
		saddr, daddr uint32
		sport, dport uint16
		cgroupID uint64
	)

	binary.Read(r, binary.LittleEndian, &timestamp)
	binary.Read(r, binary.LittleEndian, &pid)
	binary.Read(r, binary.LittleEndian, &uid)
	binary.Read(r, binary.LittleEndian, &comm)
	binary.Read(r, binary.LittleEndian, &saddr)
	binary.Read(r, binary.LittleEndian, &daddr)
	binary.Read(r, binary.LittleEndian, &sport)
	binary.Read(r, binary.LittleEndian, &dport)
	binary.Read(r, binary.LittleEndian, &cgroupID)

	return Event{
		Type:      "network.tcp_connect",
		Timestamp: time.Unix(0, int64(timestamp)),
		PID:       pid,
		UID:       uid,
		Comm:      cstr(comm[:]),
		Data: map[string]interface{}{
			"src_addr":  ipv4ToString(saddr),
			"dst_addr":  ipv4ToString(daddr),
			"src_port":  sport,
			"dst_port":  dport,
			"cgroup_id": cgroupID,
		},
	}, nil
}

// Helper functions
func cstr(b []byte) string {
	for i, c := range b {
		if c == 0 {
			return string(b[:i])
		}
	}
	return string(b)
}

func ipv4ToString(ip uint32) string {
	return net.IPv4(byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24)).String()
}

// generateMockEvents creates sample events for testing without eBPF
func (c *Collector) generateMockEvents(events chan<- Event) {
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for c.running {
		<-ticker.C

		// Generate a mock process exec event
		events <- Event{
			Type:      "process.exec",
			Timestamp: time.Now(),
			PID:       1234,
			UID:       1000,
			Comm:      "bash",
			Data: map[string]interface{}{
				"ppid":      1000,
				"filename":  "/bin/bash",
				"cgroup_id": 0,
			},
		}

		// Generate a mock TCP connect event
		events <- Event{
			Type:      "network.tcp_connect",
			Timestamp: time.Now(),
			PID:       5678,
			UID:       1000,
			Comm:      "curl",
			Data: map[string]interface{}{
				"src_addr":  "10.0.0.1",
				"dst_addr":  "93.184.216.34",
				"src_port":  uint16(45678),
				"dst_port":  uint16(443),
				"cgroup_id": 0,
			},
		}
	}
}